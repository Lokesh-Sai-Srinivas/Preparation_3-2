[
    {
        "q": "1 a) Define the Software Development Life Cycle. Explain the different stages involved in SDLC. [5M]\n\n1 b) Explain DevOps life cycle in the automation process. [5M]",
        "answer_a": "### **1 a) Software Development Life Cycle (SDLC)**\n\n**1. Definition**\n**Software Development Life Cycle (SDLC)** is a structured framework that defines the sequence of phases followed during software development to produce high-quality, reliable, and maintainable software that meets user requirements.\n\n**2. Stages of SDLC**\n\nThe SDLC consists of the following key phases:\n\n**I. Requirement Analysis**\n*   **Goal:** Identify and document what the user needs.\n*   **Activity:** Gathering functional and non-functional requirements.\n*   **Output:** Software Requirement Specification (SRS) document.\n\n**II. System Design**\n*   **Goal:** Convert requirements into a technical architecture.\n*   **Activity:** Creating High-Level Design (HLD) and Low-Level Design (LLD).\n*   **Output:** System Design Document (SDD).\n\n**III. Implementation (Coding)**\n*   **Goal:** Translate design into executable code.\n*   **Activity:** Writing code using programming languages (e.g., Java, Python).\n*   **Output:** Source Code.\n\n**IV. Testing**\n*   **Goal:** Verify that the software is defect-free.\n*   **Activity:** Unit testing, Integration testing, and System testing.\n*   **Output:** Test Reports and Bug Fixes.\n\n**V. Deployment**\n*   **Goal:** Release the software to the end-users.\n*   **Activity:** Installing the application in the production environment.\n*   **Output:** Live Application.\n\n**VI. Maintenance**\n*   **Goal:** Ensure long-term usability.\n*   **Activity:** Fixing post-release bugs and adding enhancements.\n\n**3. SDLC Stages Diagram**\n\n```\n+-------------+       +-------------+       +-------------+\n| Requirement |  -->  |   Design    |  -->  |   Coding    |\n+-------------+       +-------------+       +-------------+\n                                                  |\n                                                  v\n+-------------+       +-------------+       +-------------+\n| Maintenance |  <--  | Deployment  |  <--  |   Testing   |\n+-------------+       +-------------+       +-------------+\n```\n\n**4. Conclusion**\nSDLC provides a disciplined (step-by-step) approach to software development, ensuring better planning, quality control, and successful project delivery.",
        "graphviz_a": "digraph SDLC {\n  node [shape=box, style=filled, fillcolor=white];\n  edge [color=black];\n  Requirement -> Design -> Coding -> Testing -> Deployment -> Maintenance;\n}",
        "answer_b": "### **1 b) DevOps Life Cycle in Automation**\n\n**1. Introduction**\nThe **DevOps Life Cycle** integrates Development and Operations teams using automation to enable continuous delivery, faster releases, and improved collaboration. It is an infinite loop of continuous improvement.\n\n**2. Stages of DevOps Life Cycle**\n\n**I. Continuous Planning**\n*   Defining requirements and creating a backlog (e.g., Jira).\n\n**II. Continuous Development (Code)**\n*   Writing code and managing versions using Git.\n\n**III. Continuous Integration (Build)**\n*   Automated compilation and packaging of code (e.g., Maven, Jenkins).\n\n**IV. Continuous Testing**\n*   Automated testing to detect bugs early (e.g., Selenium, JUnit).\n\n**V. Continuous Release**\n*   Versioning and approving the build for deployment.\n\n**VI. Continuous Deployment**\n*   Deploying the application to production containers or servers (e.g., Docker, Kubernetes).\n\n**VII. Continuous Operations**\n*   Managing and maintaining the infrastructure.\n\n**VIII. Continuous Monitoring**\n*   Tracking performance and gathering user feedback (e.g., Nagios, Prometheus).\n\n**3. DevOps Automation Flow**\n\n| Stage | Automation Tool Example |\n| :--- | :--- |\n| **Code** | Git |\n| **Build** | Maven |\n| **Test** | Selenium |\n| **CI Server** | Jenkins |\n| **Deploy** | Docker/Kubernetes |\n| **Monitor** | Nagios |\n\n**4. DevOps Life Cycle Diagram**\n\n```\n   Plan -> Code -> Build -> Test\n     ^                        |\n     |                        v\n  Monitor <- Operate <- Deploy <- Release\n```\n\n**5. Conclusion**\nAutomation in the DevOps life cycle ensures speed, consistency, and reliability, allowing organizations to release software multiple times a day with confidence.",
        "graphviz_b": "digraph DevOps {\n  layout=circo;\n  Plan -> Code -> Build -> Test -> Release -> Deploy -> Operate -> Monitor -> Plan;\n}"
    },
    {
        "q": "2 a) How is code quality measured? Explain. [5M]\n\n2 b) List and explain the main bottlenecks in a delivery pipeline with examples. [5M]",
        "answer_a": "### **2 a) Code Quality Measurement**\n\n**1. Introduction**\nCode Quality measures how well software code meets requirements like reliability, maintainability, efficiency, and security. High-quality code is typically clean, documented, and bug-free.\n\n**2. Key Metrics to Measure Code Quality**\n\n**I. Cyclomatic Complexity**\n*   Measures the number of independent paths through the code.\n*   **Lower is better** (identifies complex logic that is hard to test).\n\n**II. Code Coverage**\n*   Percentage of code executed by automated tests.\n*   **Higher is better** (ensures logic is verified).\n\n**III. Code Duplication**\n*   Percentage of repeated code blocks.\n*   **Zero is ideal** (follows DRY - Don't Repeat Yourself principle).\n\n**IV. Code Churn**\n*   Frequency of changes to a file.\n*   High churn indicates instability.\n\n**V. Technical Debt**\n*   The estimated effort to fix quality issues.\n\n**3. Tools for Measurement**\n*   **SonarQube:** Comprehensive static analysis.\n*   **Checkstyle:** Coding standard enforcement.\n\n**4. Measurement Principles Table**\n\n| Metric | Desired Value | Significance |\n| :--- | :--- | :--- |\n| **Complexity** | Low | Easier to maintain |\n| **Coverage** | High (>80%) | Fewer bugs |\n| **Duplication** | Low (0%) | Better modularity |\n\n**5. Conclusion**\nMeasuring code quality is essential to prevent messy code (spaghetti code) and ensures the software remains scalable and maintainable over time.",
        "answer_b": "### **2 b) Bottlenecks in Delivery Pipeline**\n\n**1. Introduction**\nA bottleneck is a point of congestion in the DevOps pipeline that slows down the entire delivery process. Identifying constraints is crucial for flow optimization.\n\n**2. Main Bottlenecks**\n\n**I. Manual Testing**\n*   **Issue:** Relying on humans to execute regression tests.\n*   **Impact:** Delays feedback and releases.\n*   **Example:** QA team taking 3 days to manually verify a build.\n\n**II. Environment Inconsistency**\n*   **Issue:** \"It works on my machine\" syndrome.\n*   **Impact:** Deployment failures due to config mismatches.\n*   **Example:** Dev uses Windows, Prod uses Linux.\n\n**III. Manual Deployments**\n*   **Issue:** Manually copying files to servers.\n*   **Impact:** High risk of human error.\n*   **Example:** Forgeting to update a config file during release.\n\n**IV. Monolithic Architecture**\n*   **Issue:** Tightly coupled codebases.\n*   **Impact:** One small change requires rebuilding the entire system.\n\n**3. Bottleneck Visualization**\n\n```\nDev Speed: High  ----->  [ Manual Testing ]  ----->  Release: Slow\n                        (Bottleneck)\n```\n\n**4. Solutions Table**\n\n| Bottleneck | Solution |\n| :--- | :--- |\n| Manual Testing | Automated Testing (Selenium) |\n| Manual Deploy | CI/CD Tools (Jenkins) |\n| Env Issues | Containerization (Docker) |",
        "graphviz_b": "digraph Bottleneck {\n  rankdir=LR;\n  Dev -> Build -> \"Manual Test\\n(BOTTLENECK)\" -> Deploy;\n  \"Manual Test\\n(BOTTLENECK)\" [style=filled, fillcolor=red];\n}"
    },
    {
        "q": "3. Explain any 6 DevOps tools used in the software industry.   [10M]",
        "a": "### **DevOps Tools in Software Industry**\n\n**1. Introduction**\nDevOps relies on a toolchain to automate tasks across the SDLC. These tools facilitate collaboration, automation, and monitoring.\n\n**2. Top 6 DevOps Tools**\n\n**I. Git (Version Control)**\n*   **Function:** Source Code Management (SCM).\n*   **Usage:** Tracks changes, enables branching and merging.\n*   **Benefit:** Distributed development and history tracking.\n\n**II. Jenkins (Continuous Integration)**\n*   **Function:** Automation Server.\n*   **Usage:** Triggers builds, runs tests, and deploys artifacts.\n*   **Benefit:** Automates the integration process (CI/CD).\n\n**III. Docker (Containerization)**\n*   **Function:** Container Platform.\n*   **Usage:** Packages apps and dependencies into a portable container.\n*   **Benefit:** Eliminates \"works on my machine\" issues.\n\n**IV. Maven (Build Tool)**\n*   **Function:** Build Automation.\n*   **Usage:** Compiles Java code and manages dependencies (pom.xml).\n*   **Benefit:** Standardizes project structure.\n\n**V. Ansible (Configuration Management)**\n*   **Function:** Infrastructure as Code (IaC).\n*   **Usage:** Automates server provisioning and configuration.\n*   **Benefit:** Agentless and uses simple YAML syntax.\n\n**VI. Nagios (Monitoring)**\n*   **Function:** System Monitoring.\n*   **Usage:** Monitors servers, networks, and services.\n*   **Benefit:** Alerting on failures before they impact users.\n\n**3. DevOps Toolchain Table**\n\n| Category | Tool | Key Feature |\n| :--- | :--- | :--- |\n| **SCM** | Git | Distributed Version Control |\n| **CI** | Jenkins | Pipeline Automation |\n| **Build** | Maven | Dependency Management |\n| **Container** | Docker | Portable Environments |\n| **Config** | Ansible | Agentless Automation |\n| **Monitor** | Nagios | Real-time Alerting |\n\n**4. Visual Representation**\n\n```\nGit -> Maven -> Jenkins -> Docker -> Ansible -> Nagios\n(Code) (Build)   (CI)    (Pkg)    (Deploy)  (Monitor)\n```",
        "graphviz": "digraph Tools {\n  rankdir=LR;\n  Git -> Maven -> Jenkins -> Docker -> Ansible -> Nagios;\n  Jenkins [shape=doublecircle];\n}"
    },
    {
        "q": "4 a) Explain DevOps Architecture with different components. [5M]\n\n4 b) Define the CI/CD pipeline and explain its benefits, including the main phases involved. [5M]",
        "answer_a": "### **4 a) DevOps Architecture**\n\n**1. Introduction**\nDevOps architecture is designed to enable continuous collaboration between Development and Operations. It emphasizes automation at every stage.\n\n**2. Key Architecutral Components**\n\n**I. Development & Version Control**\n*   Developers write code and push to a shared repository (e.g., GitHub).\n\n**II. Continuous Integration (CI)**\n*   Automates the build and test process. Changes are integrated frequently.\n\n**III. Continuous Delivery/Deployment (CD)**\n*   Ensures that software is always in a releasable state and automates deployment.\n\n**IV. Continuous Testing**\n*   Automated tests (Unit, Integration) run on every build to ensure quality.\n\n**V. Continuous Monitoring**\n*   Real-time tracking of application health and usage patterns.\n\n**VI. Infrastructure as Code (IaC)**\n*   Managing infrastructure (servers, networks) through code scripts.\n\n**3. Architecture Diagram**\n\n```\n+-------------+      +-------------+      +-------------+\n|     Dev     | ---> |     CI      | ---> |     CD      |\n+-------------+      +-------------+      +-------------+\n       ^                                         |\n       |                                         v\n+-------------+      +-------------+      +-------------+\n|   Monitor   | <--- |     Ops     | <--- |   Deploy    |\n+-------------+      +-------------+      +-------------+\n```\n\n**4. Conclusion**\nThis architecture creates a feedback loop that allows for rapid iteration and high stability.",
        "graphviz_a": "digraph Arch {\n  rankdir=LR;\n  Dev -> CI -> CD -> Deploy -> Ops -> Monitor;\n  Monitor -> Dev [label=\"Feedback\"];\n}",
        "answer_b": "### **4 b) CI/CD Pipeline**\n\n**1. Definition**\nA **CI/CD Pipeline** is a set of automated processes that allow developers and DevOps professionals to reliably and efficiently compile, build, and deploy code to their production platforms.\n\n**2. Main Phases**\n\n*   **Source:** Code is committed to a version control system (Git).\n*   **Build:** The code is compiled, and dependencies are resolved.\n*   **Test:** Automated tests (Unit, Integration) are executed.\n*   **Deploy:** The artifact is deployed to a staging or production environment.\n\n**3. Benefits of CI/CD**\n\n*   **Faster Time to Market:** Automates manual steps, speeding up releases.\n*   **Reduced Risk:** Smaller, frequent changes are easier to fix.\n*   **Higher Quality:** Automated testing catches bugs early.\n*   **Consistent Process:** Eliminates human error in deployment.\n\n**4. Pipeline Flowchart**\n\n```\nCode Commit -> [Build] -> [Test] -> [Staging] -> [Production]\n                  |         |          |\n                (Fail)    (Fail)     (Success)\n```\n\n**5. Conclusion**\nCI/CD transforms software delivery from a slow, manual process to a rapid, automated workflow.",
        "graphviz_b": "digraph CICD {\n  rankdir=LR;\n  node [shape=rect];\n  Commit -> Build -> Test -> Deploy;\n  Build -> Fail [style=dotted];\n  Test -> Fail [style=dotted];\n}"
    },
    {
        "q": "5 a) Analyze the differences and similarities between Kanban and Scrum. [5M]\n\n5 b) Outline the working of the Delivery Pipeline. [5M]",
        "answer_a": "### **5 a) Kanban vs. Scrum**\n\n**1. Introduction**\nBoth Kanban and Scrum are Agile frameworks used to manage work, but they approach it differently. Scrum is structured and time-boxed, while Kanban is continuous and flow-based.\n\n**2. Differences Table**\n\n| Feature | Scrum | Kanban |\n| :--- | :--- | :--- |\n| **Cadence** | Sprint (Fixed 2-4 weeks) | Continuous Flow |\n| **Roles** | Product Owner, Scrum Master, Team | No predefined roles |\n| **Metrics** | Velocity | Cycle Time, Lead Time |\n| **Change** | No changes during Sprint | Change allowed anytime |\n| **Board Reset** | Reset after each Sprint | Persistent (Continuous) |\n\n**3. Similarities**\n*   Both are **Agile** methodologies.\n*   Both use **Visual Boards** (Scrum Board / Kanban Board).\n*   Both focus on **limiting work in progress** (implicitly in Scrum, explicitly in Kanban).\n*   Both emphasize **collaborative** and **self-organizing** teams.\n\n**4. Conclusion**\nChoose Scrum for projects requiring structured changes and regular feedback loops. Choose Kanban for maintenance projects or support teams requiring continuous delivery.",
        "graphviz_a": "graph Comparison {\n  node [shape=box];\n  Agile [label=\"Agile Principles\"];\n  Scrum [label=\"Scrum\\n(Time-boxed)\"];\n  Kanban [label=\"Kanban\\n(Continuous)\"];\n  Agile -- Scrum;\n  Agile -- Kanban;\n}",
        "answer_b": "### **5 b) Working of Delivery Pipeline**\n\n**1. Introduction**\nA delivery pipeline automates the movement of code from a developer's machine to the production environment.\n\n**2. Working Steps**\n\n1.  **Code Commit:** Developer pushes code to the repository.\n2.  **Trigger Build:** The CI server (Jenkins) detects the change.\n3.  **Compile & Unit Test:** Code is verified.\n4.  **Static Analysis:** Code quality check (SonarQube).\n5.  **Artifact Creation:** A binary/docker image is built.\n6.  **Staging Deploy:** Deployed to a test environment.\n7.  **Acceptance Test:** Functional testing.\n8.  **Production Deploy:** If all checks pass, it goes live.\n\n**3. Delivery Pipeline Flowchart**\n\n```\nCommit -> Build -> Test -> Analyze -> Package -> Deploy(Stage) -> Deploy(Prod)\n```\n\n**4. Conclusion**\nThe pipeline ensures that every change goes through a rigorous quality check before reaching the customer.",
        "graphviz_b": "digraph Pipeline {\n  rankdir=LR;\n  Commit -> Build -> Test -> Pkg -> Stage -> Prod;\n}"
    },
    {
        "q": "6 a) Illustrate the Agile Model and discuss the various Agile frameworks, its core principles, Pros and Cons.   [10M]",
        "a": "### **Agile Model & Frameworks**\n\n**1. Introduction**\nThe Agile Model is a customer-focused approach that delivers software in small, iterative increments. It values responding to change over following a plan.\n\n**2. Core Principles (Agile Manifesto)**\n*   **Individuals and interactions** over processes and tools.\n*   **Working software** over comprehensive documentation.\n*   **Customer collaboration** over contract negotiation.\n*   **Responding to change** over following a plan.\n\n**3. Various Agile Frameworks**\n*   **Scrum:** Most popular, uses Sprints and Roles.\n*   **Kanban:** Flow-based, uses WIP limits.\n*   **XP (Extreme Programming):** Focuses on engineering practices (TDD, Pair Programming).\n*   **Lean:** Focuses on eliminating waste.\n\n**4. Pros and Cons Table**\n\n| Pros (Advantages) | Cons (Disadvantages) |\n| :--- | :--- |\n| Fast delivery of working software | Lack of documentation |\n| Flexible to changing requirements | Scope creep risk |\n| High customer satisfaction | Needs experienced team |\n| Continuous feedback | Hard to predict final cost |\n\n**5. Agile Model Diagram**\n\n```\nStart -> [Iteration 1] -> [Iteration 2] -> [Iteration N] -> Deploy\n            |\n      (Plan-Design-Build-Test)\n```",
        "graphviz": "digraph AgileModel {\n  rankdir=TB;\n  Start -> Iteration1 -> Iteration2 -> FinalProduct;\n  Iteration1 [label=\"Iteration 1\\n(Plan, Design, Build, Test)\"];\n  Iteration2 [label=\"Iteration 2\\n(Refine, Build, Test)\"];\n}"
    },
    {
        "q": "7 a) List out the features of DevOps. [5M]\n\n7 b) Describe Build Automation and explain its benefits. [5M]",
        "answer_a": "### **7 a) Features of DevOps**\n\n**1. Introduction**\nDevOps is defined by a set of technical and cultural features that enable high-velocity software delivery.\n\n**2. Key Features**\n\n**I. Automation**\n*   The heart of DevOps. Automating build, test, and deploy reduces manual error.\n\n**II. Collaboration**\n*   Breaking down silos between Dev and Ops teams to work towards a common goal.\n\n**III. Continuous Integration (CI)**\n*   Developers integrate code frequently to detect integration issues early.\n\n**IV. Continuous Delivery (CD)**\n*   Code is automatically prepared for a release to production.\n\n**V. Continuous Monitoring**\n*   Proactive monitoring of application health using tools like Nagios.\n\n**VI. Infrastructure as Code (IaC)**\n*   Managing infrastructure using configuration files (e.g., Terraform, Ansible).\n\n**3. Features Visualization**\n\n```\n      [ Automation ]\n      [ Collaboration ]\nDevOps --> [ CI / CD ]\n      [ Monitoring ]\n      [ IaC ]\n```\n\n**4. Conclusion**\nThese features collectively enable the core benefits of DevOps: Speed, Reliability, and Scale.",
        "graphviz_a": "graph Features {\n  DevOps -- Automation;\n  DevOps -- Collaboration;\n  DevOps -- CICD;\n  DevOps -- Monitoring;\n  DevOps -- IaC;\n}",
        "answer_b": "### **7 b) Build Automation**\n\n**1. Description**\nBuild Automation is the process of scripting and automating the compilation of computer source code into binary code, packaging binary code, and running automated tests. It is the first step in a CI/CD pipeline.\n\n**2. Automated Capabilities**\n*   Compiling source code.\n*   Packaging (e.g., .jar, .war, .exe).\n*   Running unit tests.\n*   Dependency management.\n\n**3. Key Benefits**\n\n*   **Speed:** Builds are significantly faster than manual compilation.\n*   **Consistency:** Eliminates \"works on my machine\" issues; the build server environment is the truth.\n*   **Immediate Feedback:** Developers know instantly if they broke the build.\n*   **History:** Keeps a record of builds and artifacts.\n\n**4. Comparison Table**\n\n| Manual Build | Automated Build |\n| :--- | :--- |\n| Slow & Error-prone | Fast & Consistent |\n| Dependent on Human | Dependent on Script |\n| No automatic history | Logs & History preserved |\n\n**5. Conclusion**\nBuild automation tools like **Maven** and **Gradle** are essential for modern software projects to maintain efficiency.",
        "graphviz_b": "digraph BuildAutomation {\n  SourceCode -> Compiler -> UnitTests -> Packaging -> Artifact;\n}"
    },
    {
        "q": "8 a) Explore DevOps workflow and Principles. [5M]\n\n8 b) Discuss the importance of maintaining code quality and implementing CI/CD automation in DevOps. [5M]",
        "answer_a": "### **8 a) DevOps Workflow & Principles**\n\n**1. DevOps Workflow**\nThe workflow describes the sequence of automated and collaborative steps.\n\n*   **Plan:** Define task.\n*   **Code:** Write Application.\n*   **Build:** Compile & Package.\n*   **Test:** Validate.\n*   **Release:** Version.\n*   **Deploy:** Install to Prod.\n*   **Operate:** Manage Config.\n*   **Monitor:** Check Health.\n\n**2. Core Principles (CAMS)**\n\n*   **C - Culture:** People over process.\n*   **A - Automation:** Automate everything possible.\n*   **M - Measurement:** Data-driven decisions.\n*   **S - Sharing:** Open information flow.\n\n**3. Workflow Diagram**\n\n```\nPlan -> Code -> Build -> Test -> Release -> Deploy -> Operate -> Monitor\n^__________________________________________________________________|\n```\n\n**4. Conclusion**\nThe workflow facilitates a continuous feedback loop, which is the essence of the DevOps principle.",
        "graphviz_a": "digraph Workflow {\n  rankdir=LR;\n  Plan->Code->Build->Test->Release->Deploy->Operate->Monitor;\n  Monitor->Plan [constraint=false, style=dashed];\n}",
        "answer_b": "### **8 b) Importance of Code Quality & CI/CD**\n\n**1. Introduction**\nIn DevOps, speed is important, but quality is paramount. CI/CD and Code Quality checks work together to ensure fast delivery of *working* software.\n\n**2. Importance of Code Quality**\n*   **Maintainability:** Clean code is easier to update.\n*   **Reduced Technical Debt:** Prevents future rework.\n*   **Security:** Static analysis catches vulnerabilities early.\n*   **Readability:** Easier for new team members to onboard.\n\n**3. Importance of CI/CD Automation**\n*   **Market Speed:** releases happen in minutes, not months.\n*   **Reliability:** Automated tests prevent bad code from reaching production.\n*   **Productivity:** Developers focus on coding, not deploying.\n\n**4. Relationship Diagram**\n\n```\nHigh Quality Code + CI/CD Pipelines = Success\nLow Quality Code + CI/CD Pipelines = Automated Chaos\n```\n\n**5. Conclusion**\nCI/CD accelerates the process, while Code Quality standards ensure that what we are accelerating is actually good software.",
        "table_b": "| Aspect | Without CI/CD & Quality | With CI/CD & Quality |\n| :--- | :--- | :--- |\n| **Release Cycle** | Months | Hours/Days |\n| **Bug Discovery** | In Production (Costly) | During Build (Cheap) |\n| **Correction** | High Effort | Low Effort |"
    },
    {
        "q": "9 a) Describe the different Release Management practices in DevOps. [5M]\n\n9 b) List the Scrum roles and events. [5M]",
        "answer_a": "### **9 a) Release Management Practices**\n\n**1. Introduction**\nRelease management plans, schedules, and controls the build, testing, and deployment of releases.\n\n**2. Key Practices**\n\n**I. Continuous Delivery**\n*   Software is always in a releasable state. The release button is manual, but everything else is automated.\n\n**II. Blue-Green Deployment**\n*   Maintain two identical environments (Blue and Green). One is live, the other is idle. Deploy to idle, test, then switch traffic.\n*   *Benefit:* Zero downtime.\n\n**III. Canary Releases**\n*   Release the update to a small subset of users (e.g., 5%) first. If stable, roll out to everyone.\n*   *Benefit:* Low risk.\n\n**IV. Feature Flags**\n*   Deploy code with features hidden behind a toggle. Turn them on/off dynamically.\n\n**3. Practices Table**\n\n| Practice | deploy Strategy |\n| :--- | :--- |\n| **Blue-Green** | Instant switch, Zero downtime |\n| **Canary** | Gradual rollout |\n| **Feature Flags** | Code deploy != Feature release |\n\n**4. Conclusion**\nModern release practices prioritize user experience and risk minimization.",
        "answer_b": "### **9 b) Scrum Roles and Events**\n\n**1. Introduction**\nScrum is defined by specific roles to ensure accountability and events to ensure regularity.\n\n**2. Scrum Roles**\n\n*   **Product Owner (PO):** Defines *what* to build. Owns the Product Backlog and ROI.\n*   **Scrum Master:** Servants-leader. Ensures the team follows Scrum rules and removes obstacles.\n*   **Development Team:** Cross-functional group (devs, testers, designers) who do the actual work.\n\n**3. Scrum Events (Ceremonies)**\n\n*   **Sprint:** The container event (1-4 weeks).\n*   **Sprint Planning:** What can be delivered in this Sprint?\n*   **Daily Scrum:** 15-min standup. What did I do? What will I do? Blockers?\n*   **Sprint Review:** Demo of the working product to stakeholders.\n*   **Sprint Retrospective:** Team meeting to improve the process.\n\n**4. Visual Structure**\n\n```\nRoles: [PO] <-> [Scrum Master] <-> [Team]\nEvents: Planning -> Daily -> Review -> Retro\n```",
        "graphviz_b": "graph ScrumStruct {\n  subgraph cluster_roles {\n    label=\"Roles\";\n    PO; SM; Team;\n  }\n  subgraph cluster_events {\n    label=\"Events\";\n    Planning -> Daily -> Review -> Retro;\n  }\n}"
    }
]