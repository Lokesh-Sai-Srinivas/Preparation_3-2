[
    {
        "q": "1 a) What is Version Control? Explain the key features of Git. [5M]\n\n1 b) Explain GIT Workflow with an example. [5M]",
        "answer_a": "### **1 a) Version Control & Git Features**\n\n**1. Introduction**\nVersion Control is a system that records changes to a file or set of files over time so that you can recall specific versions later. Ideally, it allows multiple people to work on a project efficiently.\n\n**2. Key Features of Git**\n\n**I. Distributed Architecture**\n*   Every developer has a full copy of the repository (including history) on their local machine. No single point of failure.\n\n**II. Branching and Merging**\n*   Git's \"killer feature\". Creating branches is instant. Merging them back is easy. Encourages non-linear development.\n\n**III. Performance**\n*   Operations like committing, branching, and diffing are performed locally, making them extremely fast.\n\n**IV. Data Integrity**\n*   Everything in Git is checksummed using SHA-1. It is impossible to change file contents without Git knowing about it.\n\n**V. Staging Area**\n*   Allows developers to format commits and review changes before completing them.\n\n**3. Git Features Diagram**\n\n```\n[ Distributed ] <--- [ GIT ] ---> [ Fast ]\n        ^               |\n        |               v\n   [ Safe ]        [ Branching ]\n```",
        "graphviz_a": "graph GitFeatures {\n  node [shape=ellipse];\n  Git [label=\"GIT Features\", shape=box, style=bold];\n  Distributed; Fast; DataIntegrity; Branching; Staging;\n  Git -- Distributed;\n  Git -- Fast;\n  Git -- DataIntegrity;\n  Git -- Branching;\n  Git -- Staging;\n}",
        "answer_b": "### **1 b) GIT Workflow**\n\n**1. Introduction**\nThe standard Git workflow involves moving files between three main areas: The Working Directory, The Staging Area, and The Repository.\n\n**2. Three States of Git**\n*   **Modified:** Changed files in working directory but not yet staged.\n*   **Staged:** Files marked to go into the next commit snapshot.\n*   **Committed:** Data safely stored in the local database.\n\n**3. Workflow Steps**\n1.  **Modify** files in your working directory.\n2.  **Stage** the specific changes you want using `git add`.\n3.  **Commit** the staged changes to the repository using `git commit`.\n\n**4. Visual Diagram**\n\n```\nWorking Dir  --add-->  Staging Area  --commit-->  Local Repo\n(Modified)              (Staged)                  (Committed)\n```\n\n**5. Example**\n\n```bash\n# 1. Edit file\necho \"Hello\" > hello.txt\n# 2. Stage file\ngit add hello.txt\n# 3. Commit file\ngit commit -m \"Added hello.txt\"\n```",
        "graphviz_b": "digraph GitWorkflow {\n  rankdir=LR;\n  Working [label=\"Working Directory\"];\n  Staging [label=\"Staging Area\"];\n  Repo [label=\"Local Repository\"];\n  Working -> Staging [label=\"git add\"];\n  Staging -> Repo [label=\"git commit\"];\n}"
    },
    {
        "q": "2 a) Explain the GIT commands add, commit, status, and remote with examples. [5M]\n\n2 b) Illustrate the following GIT commands with examples - push and pull. Give the difference. [5M]",
        "answer_a": "### **2 a) Essential Git Commands**\n\n**1. git add**\n*   **Purpose:** Moves changes from the working directory to the staging area.\n*   **Syntax:** `git add <filename>` or `git add .` (for all).\n\n**2. git commit**\n*   **Purpose:** Captures a snapshot of the project's currently staged changes.\n*   **Syntax:** `git commit -m \"Message\"`\n\n**3. git status**\n*   **Purpose:** Displays the state of the working directory and staging area (shows what is modified, staged, or untracked).\n*   **Syntax:** `git status`\n\n**4. git remote**\n*   **Purpose:** Manages the set of tracked repositories.\n*   **Syntax:** `git remote -v` (view) or `git remote add origin <url>` (add new).\n\n**5. Commands Summary Table**\n\n| Command | Area Affected | Action |\n| :--- | :--- | :--- |\n| `add` | Work -> Stage | Prepare snapshot |\n| `commit`| Stage -> Repo | Save snapshot |\n| `status`| All | View state |\n| `remote`| Config | Link to server |",
        "answer_b": "### **2 b) Git Push & Pull**\n\n**1. Introduction**\nThese commands are used to synchronize the local repository with a remote repository (like GitHub).\n\n**2. git push**\n*   **Description:** Uploads local repository content to a remote repository.\n*   **Example:** `git push origin main`\n\n**3. git pull**\n*   **Description:** Fetches and downloads content from a remote repository and immediately updates the local repository to match that content.\n*   **Technically:** `git pull` = `git fetch` + `git merge`.\n*   **Example:** `git pull origin main`\n\n**4. Difference Table**\n\n| Feature | git push | git pull |\n| :--- | :--- | :--- |\n| **Direction** | Local -> Remote | Remote -> Local |\n| **Purpose** | Share changes | Update local code |\n| **Risk** | Can reject if conflicts exist | Can create merge conflicts |\n\n**5. Visual Diagram**\n\n```\n      [ Remote Repo ]\n      /            \\\n   (Pull)        (Push)\n    /                \\\n[ Local Repo ]    [ Local Repo ]\n```",
        "graphviz_b": "digraph PushPull {\n  rankdir=BT;\n  Local [label=\"Local Repository\"];\n  Remote [label=\"Remote Repository\"];\n  Local -> Remote [label=\"git push\"];\n  Remote -> Local [label=\"git pull\"];\n}"
    },
    {
        "q": "3 a) Explain unit testing and describe how code is tested with an example. [5M]\n\n3 b) Discuss the metrics used in software testing and explain different types of code coverage tools with examples. [5M]",
        "answer_a": "### **3 a) Unit Testing**\n\n**1. Definition**\nUnit testing is a software testing method where individual units or components of software (functions, methods, classes) are tested in isolation to determine if they are fit for use.\n\n**2. How Code is Tested**\n*   **Step 1:** Isolate the function to test.\n*   **Step 2:** Create a test case with specific inputs.\n*   **Step 3:** Define the *expected* output.\n*   **Step 4:** Run the test framework (Assert).\n*   **Step 5:** Compare *actual* vs *expected*.\n\n**3. Example (Java/JUnit)**\n\n*Code to Test:*\n```java\npublic int add(int a, int b) {\n    return a + b;\n}\n```\n\n*Test Code:*\n```java\n@Test\npublic void testAdd() {\n    MyMath math = new MyMath();\n    // Assert that 2+3 equals 5\n    assertEquals(5, math.add(2, 3));\n}\n```\n\n**4. Testing Process Flow**\n\n```\nWrite Code -> Write Test -> Run Test -> (Pass/Fail) -> Refactor\n```\n\n**5. Conclusion**\nIt is the foundation of the \"Test Pyramid\" and provides the fastest feedback to developers.",
        "graphviz_a": "digraph UnitTest {\n  rankdir=LR;\n  Input -> Function -> ActualOutput;\n  Input -> \"Expected Output\";\n  ActualOutput -> Compare;\n  \"Expected Output\" -> Compare;\n  Compare -> Result;\n}",
        "answer_b": "### **3 b) Testing Metrics & Coverage Tools**\n\n**1. Software Testing Metrics**\nMetrics help in evaluating the quality and progress of testing.\n\n*   **Defect Density:** `Defects / Size of Release`.\n*   **Test Failure Rate:** `% of tests failing`.\n*   **Test Coverage:** `% of requirements covered`.\n*   **Code Coverage:** `% of code lines executed`.\n\n**2. Code Coverage Tools**\n\n**I. JaCoCo (Java)**\n*   **Description:** Lightweight Java Code Coverage library.\n*   **Integration:** Works with Maven/Gradle/Jenkins.\n\n**II. Cobertura (Java)**\n*   **Description:** Calculates percentage of code accessed by tests.\n*   **Report:** XML/HTML reports.\n\n**III. ISTANBUL (JavaScript)**\n*   **Description:** Popular for JS applications.\n\n**IV. NCover (.NET)**\n*   **Description:** For C#/.NET applications.\n\n**3. Coverage Types Table**\n\n| Type | What it validates? |\n| :--- | :--- |\n| **Statement** | Was the line executed? |\n| **Branch** | Did we take every if/else path? |\n| **Function** | Was the function called? |\n\n**4. Conclusion**\nTools like JaCoCo are essential in CI pipelines to gate builds (e.g., fail build if coverage < 80%)."
    },
    {
        "q": "4 a) What is GIT Branching? Demonstrate how to create and delete branches in GIT using appropriate commands. [5M]\n\n4 b) Describe GIT and outline its benefits. [5M]",
        "answer_a": "### **4 a) Git Branching**\n\n**1. Definition**\nBranching means you diverge from the main line of development and continue to do work without messing with that main line. In Git, branches are effectively a pointer to a snapshot of your changes.\n\n**2. Key Benefit**\nAllows parellel development of features, bug fixes, and experiments safely.\n\n**3. Commands Demonstration**\n\n**I. Create a new branch**\n*   `git branch <branch-name>`\n*   *Example:* `git branch feature-login`\n\n**II. Switch to a branch**\n*   `git checkout <branch-name>`\n*   *Example:* `git checkout feature-login`\n*   *Shortcut:* `git checkout -b feature-login` (Create & Switch)\n\n**III. Delete a branch**\n*   `git branch -d <branch-name>` (Safe delete)\n*   `git branch -D <branch-name>` (Force delete)\n*   *Example:* `git branch -d feature-login`\n\n**4. Branching Diagram**\n\n```\n      (A) --- (B) --- (C)  <-- Main Branch\n               \\\n                (D) --- (E) <-- Feature Branch\n```",
        "graphviz_a": "graph Branching {\n  rankdir=LR;\n  node [shape=circle];\n  C1 -> C2 -> C3;\n  C2 -> F1 -> F2;\n  C3 [label=\"Main\"];\n  F2 [label=\"Feature\"];\n}",
        "answer_b": "### **4 b) Git & Its Benefits**\n\n**1. Description**\nGit is a DevOps tool used for source code management. It is a free and open-source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.\n\n**2. Benefits of Git**\n\n**I. Distributed & Offline Capable**\n*   Developers can work completely offline and commit changes locally. Syncing only happens when pushing/pulling.\n\n**II. Cheap Branching & Merging**\n*   Creating branches is instantaneous. This encourages workflow experimentation.\n\n**III. Small & Fast**\n*   Git compresses data efficiently and is faster than centralized systems like SVN.\n\n**IV. Staging Area**\n*   Unique verification zone before committing.\n\n**V. Open Source**\n*   Standard for the industry and has massive community support.\n\n**3. Comparison to Centralized VCS**\n\n| Git (Distributed) | SVN (Centralized) |\n| :--- | :--- |\n| Offline Work | Requires Connection |\n| Local History | History on Server |\n| Fast | Slower |\n\n**4. Conclusion**\nGit is the standard language of software collaboration today."
    },
    {
        "q": "5 a) Illustrate the GIT staging area with examples. [5M]\n\n5 b) Define Unit Testing. Describe the benefits of using Unit Testing. [5M]",
        "answer_a": "### **5 a) GIT Staging Area**\n\n**1. Definition**\nThe Staging Area (or Index) is an intermediate buffer between your working directory and the repository configuration. It lets you format and review a commit before making it.\n\n**2. Purpose**\n*   It allows you to commit only specific parts of your modifications.\n*   It provides a review step to prevent bad code from entering history.\n\n**3. The Three Areas**\n1.  **Working Directory:** Sandbox where you edit files.\n2.  **Staging Area:** Files prepared for next commit.\n3.  **Repository:** Files permanently stored.\n\n**4. Visual Illustration**\n\n```\n[Edit File] -> (git add) -> [Stage Area] -> (git commit) -> [Repository]\n```\n\n**5. Example Scenario**\n\n*   You modify `A.txt` and `B.txt`.\n*   You only want `A.txt` in the next version.\n*   `git add A.txt` (Moves A to Stage).\n*   `git commit` (Saves A).\n*   `B.txt` remains modified but not committed.\n\n**6. Conclusion**\nThe staging area gives developers precision control over version history.",
        "graphviz_a": "digraph Staging {\n  rankdir=LR;\n  Working [label=\"Working Directory\", shape=folder];\n  Stage [label=\"Staging Area\\n(Index)\", shape=box, style=filled, fillcolor=yellow];\n  Repo [label=\"Repository\", shape=cylinder];\n  Working -> Stage [label=\"git add\"];\n  Stage -> Repo [label=\"git commit\"];\n}",
        "answer_b": "### **5 b) Unit Testing Benefits**\n\n**1. Definition**\nUnit testing is a level of software testing where individual units/components of a software are tested. The purpose is to validate that each unit of the software performs as designed.\n\n**2. Benefits**\n\n**I. Debugging is Easier**\n*   When a test fails, you know exactly which unit is faulty. No need to search the entire system.\n\n**II. Reduces Cost**\n*   Bugs found early (Unit level) are much cheaper to fix than bugs found in Production.\n\n**III. Documentation**\n*   Unit tests act as live documentation. Developers can look at tests to understand what a function is supposed to do.\n\n**IV. Confidence to Refactor**\n*   Create a safety net. You can improve code structure; if tests pass, you didn't break anything.\n\n**3. Cost of Change Curve**\n\n```\nCost to Fix\n    |\n    |                    (Production: $$$$)\n    |             (System Test: $$)\n    |      (Unit Test: $)\n    +-------------------------------------> Time\n```\n\n**4. Conclusion**\nUnit testing is the disciplined approach to ensuring code reliability from day one."
    },
    {
        "q": "6 a) Describe the role of remote repositories in Git and outline the related commands. [5M]\n\n6 b) Compare Git with other version control systems. [5M]",
        "answer_a": "### **6 a) Remote Repositories**\n\n**1. Introduction**\nA remote repository is a version of your project that is hosted on the internet or network (e.g., GitHub, GitLab). It is the central hub for team collaboration.\n\n**2. Role**\n*   **Collaboration:** Central point for team members to push/pull changes.\n*   **Backup:** Acts as an off-site backup of the code.\n*   **CI/CD Trigger:** Pushing to remote triggers build pipelines.\n\n**3. Related Commands**\n\n*   **`git remote -v`**\n    *   Lists all remotes associated with the folder.\n*   **`git remote add <name> <url>`**\n    *   Connects a local folder to a remote server.\n*   **`git fetch <remote>`**\n    *   Downloads data but doesn't merge.\n*   **`git push <remote> <branch>`**\n    *   Uploads data.\n*   **`git pull <remote> <branch>`**\n    *   Downloads and merges.\n\n**4. Visual Flow**\n\n```\nDev A -> Push -> [REMOTE REPO] -> Pull -> Dev B\n```",
        "graphviz_a": "digraph Remote {\n  node [shape=box];\n  Remote [label=\"Remote Repository\\n(GitHub)\", style=filled, fillcolor=lightblue];\n  Dev1 [label=\"Developer A\"];\n  Dev2 [label=\"Developer B\"];\n  Dev1 -> Remote [label=\"Push\"];\n  Remote -> Dev2 [label=\"Pull\"];\n}",
        "answer_b": "### **6 b) Git vs Other VCS**\n\n**1. Introduction**\nVersion control systems are categorized into **Centralized (CVCS)** like SVN/CVS and **Distributed (DVCS)** like Git/Mercurial.\n\n**2. Comparison Table**\n\n| Feature | Git | SVN (Subversion) | CVS |\n| :--- | :--- | :--- | :--- |\n| **Architecture** | Distributed | Centralized | Centralized |\n| **Offline Work** | Full capability | Limited | Minimal |\n| **Speed** | Extremely Fast | Slower (Network dependent) | Slow |\n| **Branching** | Cheap & Easy | Expensive (Folder copy) | Difficult |\n| **Data Integrity** | High (SHA-1) | Moderate | Low |\n| **Storage** | Snapshot-based | File-diff based | File-based |\n\n**3. Key Advantage of Git**\nUnlike SVN/CVS where the history is only on the server, Git gives every developer a full backup of the project history.\n\n**4. Diagram**\n\n```\n   [ SVN ]                [ GIT ]\nServer-Client           Peer-to-Peer\nDependency              Independence\n```"
    },
    {
        "q": "7 a) Briefly explain commonly used Git configuration commands with examples. [5M]\n\n7 b) Explain the commands used to set up a Git repository. [5M]",
        "answer_a": "### **7 a) Git Configuration**\n\n**1. Introduction**\nBefore using Git, it creates a configuration file (`.gitconfig`) to customize the environment. Setting user identity is mandatory.\n\n**2. Common Commands**\n\n**I. Set User Name**\n*   `git config --global user.name \"Name\"`\n*   *Why?* Attaches your name to every commit.\n\n**II. Set Email**\n*   `git config --global user.email \"email@example.com\"`\n*   *Why?* Identification for collaboration.\n\n**III. Set Editor**\n*   `git config --global core.editor \"code --wait\"`\n*   *Why?* Opens VS Code for commit messages instead of VIM.\n\n**IV. Check Config**\n*   `git config --list`\n*   *Why?* Verify settings.\n\n**3. Configuration Levels**\n*   **--system:** Applied to entire computer.\n*   **--global:** Applied to current user (Most common).\n*   **--local:** Applied to specific project.\n\n**4. Example Session**\n\n```bash\n$ git config --global user.name \"John Doe\"\n$ git config --global user.email \"john@doe.com\"\n```",
        "answer_b": "### **7 b) Setting up Git Repository**\n\n**1. Introduction**\nA repository can be created from scratch (init) or copied from an existing one (clone).\n\n**2. Commands**\n\n**I. git init**\n*   **Description:** Converts the current directory into a Git repository.\n*   **Action:** Creates a hidden `.git` folder.\n*   **Example:**\n    ```bash\n    mkdir myproject\n    cd myproject\n    git init\n    ```\n\n**II. git clone**\n*   **Description:** Downloads a repository from a server.\n*   **Action:** Recreates the entire project + history locally.\n*   **Example:**\n    ```bash\n    git clone https://github.com/user/repo.git\n    ```\n\n**3. Setup Workflow**\n\n```\nStart -> New Project? --(Yes)--> git init\n            |\n           (No)\n            v\n         Remote Project? --(Yes)--> git clone\n```\n\n**4. Post-Setup**\nAfter init or clone, the folder is ready for version control commands like `add` and `commit`."
    },
    {
        "q": "8 a) Discuss the purpose of JUnit and outline its usage with examples. [5M]\n\n8 b) Elaborate on the code coverage features in NUnit with examples. [5M]",
        "answer_a": "### **8 a) JUnit Purpose & Usage**\n\n**1. Purpose**\nJUnit is an open-source testing framework heavily used by Java developers to write and execute repeatable automated tests.\n\n*   **Regression Safety:** Ensures code changes don't break existing features.\n*   **Documentation:** Tests explain how code behaves.\n*   **Quality:** Enforces logic verification.\n\n**2. Usage Steps**\n1.  **Annotate** a method with `@Test`.\n2.  **Execute** the function being tested.\n3.  **Assert** the expected result matches actual result.\n\n**3. Key Annotations**\n*   `@Test`: Identifies a test method.\n*   `@Before`: Runs before every test (setup).\n*   `@After`: Runs after every test (cleanup).\n\n**4. Usage Example**\n\n```java\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class CalculatorTest {\n    @Test\n    public void testAddition() {\n        Calculator calc = new Calculator();\n        // Syntax: assertEquals(expected, actual)\n        assertEquals(10, calc.sum(5, 5));\n    }\n}\n```\n\n**5. Conclusion**\nJUnit is the backbone of TDD (Test Driven Development) in the Java Ecosystem.",
        "answer_b": "### **8 b) NUnit Code Coverage**\n\n**1. Introduction**\nNUnit is a testing framework for .NET languages (C#). Code coverage analyzes which statements of the code are executed during the NUnit test run.\n\n**2. Features**\nNUnit works with tools like **OpenCover** or **Visual Studio Coverage** to provide:\n\n*   **Visual Highlights:** Shows green (covered) or red (uncovered) lines in the editor.\n*   **Percentage Reports:** \"85% of code tested\".\n*   **Branch Analysis:** Checks if both 'true' and 'false' conditions in an `if` statement were tested.\n\n**3. Example Scenario**\n\n*Source (C#):*\n```csharp\npublic string CheckNum(int i) {\n    if (i > 10) return \"High\";\n    else return \"Low\";\n}\n```\n\n*Test 1 (Partial Coverage):*\n```csharp\n[Test]\npublic void TestHigh() { Assert.AreEqual(\"High\", CheckNum(20)); }\n```\n*   *Result:* 50% Coverage (Only 'High' path tested).\n\n*Test 2 (Full Coverage):*\n```csharp\n[Test]\npublic void TestLow() { Assert.AreEqual(\"Low\", CheckNum(5)); }\n```\n*   *Result:* 100% Coverage (Both paths tested).\n\n**4. Benefit**\nEnsures that no logic is left untested, preventing hidden bugs."
    },
    {
        "q": "9. Describe how code coverage is analyzed and reported using SonarQube.   [10M]",
        "a": "### **Code Coverage Analysis with SonarQube**\n\n**1. Introduction**\nSonarQube is a centralized code quality platform. It doesn't calculate coverage itself but **aggregates and visualizes** reports from unit testing tools (like JaCoCo, NUnit).\n\n**2. Analysis Process**\n\n**Step 1: Run Tests & Generate Report**\n*   Developer runs tests locally or in CI (Jenkins).\n*   Coverage tool (e.g., JaCoCo for Java) generates a raw report (e.g., `jacoco.xml`).\n\n**Step 2: Sonar Scanner**\n*   The Sonar Scanner reads the source code and the XML report.\n*   It maps the coverage data to the source files.\n\n**Step 3: Dashboard Visualization**\n*   SonarQube UI shows a dashboard with:\n    *   **Coverage %:** Overall project health.\n    *   **Uncovered Lines:** Exact lines missed by tests.\n    *   **Conditions:** Branch coverage stats.\n\n**3. Reporting Features**\n\n**I. Quality Gates**\n*   You can set a rule: *\"Block deployment if Coverage < 80%\"*.\n*   If the gate fails, the pipeline stops.\n\n**II. Drill-down View**\n*   Clicking on a file shows the code. Green bars = Tested. Red bars = Untested. This guides developers on where to write more tests.\n\n**III. History/Traits**\n*   Shows if coverage is improving or worsening over time.\n\n**4. Visual Flow**\n\n```\n[Code] -> [JUnit/JaCoCo] -> [XML Report] -> [SonarQube] -> [Dashboard/Quality Gate]\n```\n\n**5. Conclusion**\nSonarQube transforms raw coverage data into actionable insights, enforcing quality standards across the organization.",
        "graphviz": "digraph SonarQube {\n  rankdir=TB;\n  Tests [label=\"Unit Tests\\n(JUnit)\"];\n  Report [label=\"Coverage Report\\n(XML)\"];\n  Scanner [label=\"Sonar Scanner\"];\n  Dashboard [label=\"SonarQube Dashboard\"];\n  Gate [label=\"Quality Gate\\n(Pass/Fail)\"];\n  Tests -> Report;\n  Report -> Scanner;\n  Scanner -> Dashboard;\n  Dashboard -> Gate;\n}"
    }
]