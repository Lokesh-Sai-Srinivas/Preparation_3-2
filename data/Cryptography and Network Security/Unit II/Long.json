[
    {
        "q": "a. Describe finite fields GF(p) and GF(2n) and explain why GF(2n) fields are preferred in cryptography.\n\nb. Explain the key expansion process in AES.",
        "answer_a": "### **1(a). Finite Fields GF(p) and GF(2ⁿ)**\n\n**1. Introduction**\nA Finite Field (Galois Field) is a set with a finite number of elements where addition, subtraction, multiplication, and division are defined and behave like rational numbers. They are the backbone of modern cryptography.\n\n**2. Prime Fields GF(p)**\n*   **Definition:** A field with $p$ elements, where $p$ is a prime number.\n*   **Elements:** The set of integers $Z_p = \\{0, 1, 2, \\dots, p-1\\}$.\n*   **Operations:** Arithmetic is performed modulo $p$.\n*   **Key Property:** Any non-zero element has a unique multiplicative inverse.\n*   **Usage:** RSA, Elliptic Curve Cryptography.\n\n**3. Extension Fields GF(2ⁿ)**\n*   **Definition:** A field with $2^n$ elements.\n*   **Polynomial Representation:** Elements are not integers, but polynomials of degree $n-1$ with binary coefficients (0 or 1).\n*   **Addition:** Polynomial addition modulo 2 (which is exactly the **XOR** operation).\n*   **Multiplication:** Polynomial multiplication modulo an **Irreducible Polynomial** of degree $n$.\n\n**4. Why GF(2ⁿ) is Preferred in Cryptography?**\n*   **Hardware Efficiency:** Since coefficients are binary (0/1), addition is just an XOR gate. No carry propagation logic is needed.\n*   **Storage Efficiency:** Elements map perfectly to computer bytes/words. E.g., $GF(2^8)$ fits exactly in 1 byte (8 bits).\n*   **Fixed Size:** Unlike integer arithmetic where results grow, field operations always stay within $n$ bits.\n\n**5. Conclusion**\n$GF(2^n)$ bridges the gap between abstract algebra and digital circuit design.",
        "table_a": "| Feature | GF(p) | GF(2ⁿ) |\n| :--- | :--- | :--- |\n| **Elements** | Integers mod p | Polynomials |\n| **Modulus** | Specific Prime $p$ | Irreducible Polynomial |\n| **Addition** | Integer Add | Bitwise XOR (Fast) |\n| **Multiplication** | Integer Mult | Poly Mult + Shift |\n| **Preference** | Public Key Crypto | Symmetric Crypto (AES) |",
        "answer_b": "### **1(b). AES Key Expansion**\n\n**1. Objective**\nTo expand the initial cipher key (128, 192, or 256 bits) into a series of **Round Keys**, providing a unique key for each round of encryption. For AES-128, we need 176 bytes (44 words).\n\n**2. Core Components**\n*   **Word:** A group of 32 bits (4 bytes).\n*   **$N_k$:** Number of words in initial key (4 for AES-128).\n*   **Rcon:** Round Constants to eliminate symmetry.\n\n**3. The Algorithm**\nThe first $N_k$ words are the user's key. Subsequent words $w[i]$ are derived recursively:\n*   **Standard Case:** $w[i] = w[i-1] \\oplus w[i-N_k]$. (New word is XOR of previous word and word one block back).\n*   **Exception (Every $N_k^{th}$ word):** If $i$ is a multiple of $N_k$, apply complex transform $g(w[i-1])$ before XORing.\n\n**4. The g() Function (Complex Transform)**\nHappens once per round. It adds non-linearity to the key schedule.\n1.  **RotWord:** Circular left shift of bytes $[a, b, c, d] \\to [b, c, d, a]$.\n2.  **SubWord:** Apply AES S-Box to each byte.\n3.  **Rcon XOR:** XOR the first byte with a Round Constant ($Rcon[j]$). $Rcon$ grows in $GF(2^8)$ as powers of 2 ($1, 2, 4, 8, \\dots$).\n\n**5. Conclusion**\nKey expansion ensures that every round key is statistically independent and highly diffused from the master key.",
        "graphviz_b": "digraph KeyExp {\n  rankdir=LR;\n  node [shape=box];\n  \n  LastW [label=\"Word w[i-1]\"];\n  OldW [label=\"Word w[i-Nk]\"];\n  \n  Check [label=\"i % Nk == 0?\", shape=diamond];\n  func [label=\"g() Transform\\n(Rot+Sub+Rcon)\", style=filled, fillcolor=salmon];\n  XOR [label=\"XOR\", shape=circle, style=filled, fillcolor=lightgrey];\n  NewW [label=\"New Word w[i]\"];\n  \n  LastW -> Check;\n  Check -> func [label=\"Yes\"];\n  Check -> XOR [label=\"No\"];\n  func -> XOR;\n  OldW -> XOR;\n  XOR -> NewW;\n}"
    },
    {
        "q": "Explain in detail the structure of DES.",
        "a": "### **Structure of Data Encryption Standard (DES)**\n\n**1. Introduction**\nDES is a symmetric-key block cipher based on the **Feistel Network**. It encrypts 64-bit plaintext blocks using a 56-bit key through 16 identical rounds.\n\n**2. High-Level Architecture**\n*   **Input:** 64-bit Plaintext.\n*   **Initial Permutation (IP):** Reorders bits (no cryptographic significance).\n*   **16 Iterations:** The core processing loop.\n*   **Inverse IP ($IP^{-1}$):** Reverses the initial reordering.\n*   **Output:** 64-bit Ciphertext.\n\n**3. The Feistel Round Structure**\nIn each round $i$ (1 to 16):\n*   The block is split into Left ($L_{i-1}$) and Right ($R_{i-1}$) 32-bit halves.\n*   **$L_i = R_{i-1}$** (Left takes previous Right).\n*   **$R_i = L_{i-1} \\oplus f(R_{i-1}, K_i)$** (Right is XOR of old Left and function output).\n*   This structure ensures that encryption and decryption are identical operations; only the key order is reversed.\n\n**4. The Round Function $f(R, K)$**\nThis is the heart of DES security:\n1.  **Expansion (E-Box):** Expands 32-bit Right half to 48 bits.\n2.  **Key XOR:** Result is XORed with 48-bit Subkey $K_i$.\n3.  **Substitution (S-Boxes):** 48 bits are split into 8 chunks of 6 bits. Each chunk goes through an S-Box to produce 4 bits. **(Confusion)**.\n4.  **Permutation (P-Box):** The resulting 32 bits are shuffled. **(Diffusion)**.\n\n**5. Key Schedule**\n*   Original 64-bit key $\\to$ Drop parity bits $\\to$ 56 bits.\n*   Circular shifts left (by 1 or 2 bits) per round.\n*   Compression Permutation (PC-2) selects 48 bits for the round key.\n\n**6. Conclusion**\nDES set the standard for block cipher design, introducing the concepts of Confusion and Diffusion widely.",
        "graphviz": "digraph DES {\n  rankdir=TD;\n  node [shape=box];\n  \n  Plain [label=\"Plaintext (64)\"];\n  IP [label=\"Initial Permutation\"];\n  Round [label=\"16 Feistel Rounds\\n(Split L/R, f-function, Swap)\", style=filled, fillcolor=lightyellow];\n  Swap [label=\"32-bit Swap\"];\n  InvIP [label=\"Inverse IP\"];\n  Cipher [label=\"Ciphertext (64)\"];\n  \n  Plain -> IP -> Round -> Swap -> InvIP -> Cipher;\n}",
        "table": "| Stage | Input Size | Output Size | Operation |\n| :--- | :--- | :--- | :--- |\n| **IP** | 64 bits | 64 bits | Reordering |\n| **f-Function** | 32 bits | 32 bits | Sub/Perm/XOR |\n| **Expansion** | 32 bits | 48 bits | Duplication |\n| **S-Box** | 48 bits | 32 bits | Non-linear Sub |\n| **P-Box** | 32 bits | 32 bits | Linear Perm |"
    },
    {
        "q": "a. Explain the evolution of Feistel cipher design: first thought, improved design, and final design.\n\nb. Describe about the Security in DES.",
        "answer_a": "### **3(a). Evolution of Feistel Cipher Design**\n\nThe Feistel structure is an ingenious design allowing reversible encryption using non-reversible components.\n\n**1. First Thought (Basic Concept)**\n*   **Idea:** Split block into $L, R$. Swap them. Perform logic.\n*   **Flaw:** If the function is linear or fixed, it provides no security. Without a key, anyone knows the algorithm.\n\n**2. Improved Design (Key Introduction)**\n*   **Idea:** Introduce a Key ($K$) into the function: $f(R, K)$.\n*   **Mechanism:** $R_i = L_{i-1} \\oplus f(R_{i-1}, K)$.\n*   **Benefit:** Output now depends on a secret.\n*   **Flaw:** A single round provides insufficient mixing. One bit of input changes only a few bits of output.\n\n**3. Final Design (Iterated Rounds)**\n*   **Idea:** Repeat the process for $N$ rounds (e.g., 16).\n*   **Avalanche Effect:** By round 3 or 4, the data is completely scrambled.\n*   **Symmetry:** Decryption uses the exact same circuit, just applying keys in reverse order ($K_{16} \\to K_1$).\n\n**4. Conclusion**\nThis design allows us to focus entirely on making the round function $f$ strong, without worrying about whether $f$ itself is invertible.",
        "table_a": "| Stage | Feature | Weakness/Strength |\n| :--- | :--- | :--- |\n| **First** | Fixed Logic | Trivial to Reverse |\n| **Improved**| Keyed Logic | Poor Diffusion (1 round) |\n| **Final** | Multiple Rounds | Strong Avalanche Effect |",
        "answer_b": "### **3(b). Security Analysis of DES**\n\n**1. Introduction**\nDES was the federal standard for 20 years. Its security has been exhaustively analyzed.\n\n**2. Weakness: Key Size (Brute Force)**\n*   **Fact:** Key is 56 bits.\n*   **Space:** $2^{56} \\approx 7.2 \\times 10^{16}$ keys.\n*   **Attack:** In 1999, distributed.net cracked a key in 22 hours. Today, it takes minutes.\n*   **Verdict:** **Insecure** against brute force.\n\n**3. Strength: Cryptanalytic Resistance**\n*   **Differential Cryptanalysis:** DES S-Boxes were specifically designed to resist this. It requires $2^{47}$ chosen plaintexts, which is harder than brute force.\n*   **Linear Cryptanalysis:** Can break DES with $2^{43}$ known plaintexts. This is the only theoretical weakness better than brute force, but practically difficult to execute.\n*   **Avalanche Effect:** DES has excellent diffusion; changing 1 bit produces uncorrelated changes in output.\n\n**4. Conclusion**\nDES is cryptographically strong in its logic (algorithm) but technically weak due to its short key length. This led to the adoption of Triple DES and later AES.",
        "graphviz_b": "digraph DESSecurity {\n  node [shape=box];\n  DES [label=\"DES Security\", shape=ellipse, style=filled, fillcolor=lightgrey];\n  \n  Weak [label=\"Weakness:\\n56-bit Key\", style=filled, fillcolor=lightpink];\n  Strong [label=\"Strength:\\nS-Box Design\", style=filled, fillcolor=lightgreen];\n  \n  Brute [label=\"Brute Force\\n(Fatal)\"];\n  Diff [label=\"Differential Cryptanalysis\\n(Resistant)\"];\n  Linear [label=\"Linear Cryptanalysis\\n(Theoretical)\"];\n  \n  DES -> Weak;\n  DES -> Strong;\n  Weak -> Brute;\n  Strong -> Diff;\n  Strong -> Linear;\n}"
    },
    {
        "q": "a. Explain about Lagrange’s theorem. Find all subgroups and orders of the subgroup of the group G = < Z16, + >.\n\nb. Describe about the modern stream ciphers.",
        "answer_a": "### **4(a). Lagrange’s Theorem & Subgroups of $Z_{16}$**\n\n**1. Lagrange’s Theorem**\n*   **Statement:** For any finite group $G$, the order (size) of every subgroup $H$ must divide the order of $G$.\n*   **Formula:** $|H| \\mid |G|$.\n*   **Implication:** If a group has 16 elements, you cannot have a subgroup of size 3, 5, or 7.\n\n**2. Analysis of $G = \\langle Z_{16}, + \\rangle$**\n*   **Group:** Integers modulo 16 $\\{0, 1, \\dots, 15\\}$.\n*   **Order $|G|$:** 16.\n*   **Possible Subgroup Orders:** Divisors of 16 are $1, 2, 4, 8, 16$.\n\n**3. Finding Subgroups (Cyclic)**\n*   **Order 1:** $\\{0\\}$. Generated by $\\langle 0 \\rangle$.\n*   **Order 2:** $\\{0, 8\\}$. Generated by $\\langle 8 \\rangle$. ($8+8=16 \\equiv 0$).\n*   **Order 4:** $\\{0, 4, 8, 12\\}$. Generated by $\\langle 4 \\rangle$.\n*   **Order 8:** $\\{0, 2, 4, 6, 8, 10, 12, 14\\}$. Generated by $\\langle 2 \\rangle$.\n*   **Order 16:** The whole group. Generated by $\\langle 1 \\rangle, \\langle 3 \\rangle, \\dots$ (any odd number).\n\n**4. Conclusion**\nThe subgroups form a neat lattice structure contained within each other.",
        "table_a": "| Order | Generator | Elements |\n| :--- | :--- | :--- |\n| **1** | $\\langle 0 \\rangle$ | $\\{0\\}$ |\n| **2** | $\\langle 8 \\rangle$ | $\\{0, 8\\}$ |\n| **4** | $\\langle 4 \\rangle$ | $\\{0, 4, 8, 12\\}$ |\n| **8** | $\\langle 2 \\rangle$ | $\\{0, 2, 4, \\dots, 14\\}$ |\n| **16** | $\\langle 1 \\rangle$ | $Z_{16}$ |",
        "answer_b": "### **4(b). Modern Stream Ciphers**\n\n**1. Definition**\nA stream cipher encrypts plaintext one bit or byte at a time by combining it with a pseudorandom keystream. It essentially mimics the One-Time Pad but with a generated key.\n\n**2. Core Components**\n*   **Keystream Generator:** A state machine driven by a Key ($K$) and Initialization Vector ($IV$) to output a random stream ($S$).\n*   **Mixing Function:** Usually bitwise XOR ($\\oplus$).\n    *   $C_i = P_i \\oplus S_i$\n\n**3. Advantages**\n*   **Speed:** Extremely fast in software and hardware.\n*   **Low Latency:** No need to wait for a full block; encrypts data as it arrives (ideal for Voice/Video).\n*   **Error Tolerance:** 1 bit error in transmission corrupts only 1 bit of plaintext.\n\n**4. Modern Algorithms**\n*   **ChaCha20:** The gold standard today (Google, Cloudflare). Secure and faster than AES on mobile devices.\n*   **RC4:** Formerly dominant (WEP, SSL) but now insecure and deprecated.\n\n**5. Conclusion**\nStream ciphers are preferred for low-latency communication (IoT, Mobile) where block ciphers might be too heavy or buffering is unacceptable.",
        "graphviz_b": "digraph Stream {\n  rankdir=LR;\n  node [shape=box];\n  \n  Key [label=\"Key + IV\"];\n  Gen [label=\"Keystream Generator\\n(PRNG)\", style=filled, fillcolor=lightblue];\n  Stream [label=\"Keystream Bits (S)\"];\n  Plain [label=\"Plaintext Stream (P)\"];\n  XOR [label=\"XOR (⊕)\", shape=circle, style=filled, fillcolor=lightgrey];\n  Cipher [label=\"Ciphertext (C)\"];\n  \n  Key -> Gen -> Stream;\n  Stream -> XOR;\n  Plain -> XOR -> Cipher;\n}"
    },
    {
        "q": "Explain in detail the transformers of AES.",
        "a": "### **Transformers of AES (The 4 Layers)**\n\n**1. Introduction**\nAES processes a 128-bit block arranged as a $4 \\times 4$ matrix of bytes called the **State**. In each round, four transformations are applied to this state to achieve security.\n\n**2. Layer 1: SubBytes (Confusion)**\n*   **Operation:** A non-linear byte substitution.\n*   **Mechanism:** Each byte is replaced with another byte using a fixed S-Box (Substitution Table).\n*   **Math:** Byte is inverted in $GF(2^8)$ then affinely transformed.\n*   **Purpose:** This is the *only* non-linear step. It hides the relationship between key and ciphertext.\n\n**3. Layer 2: ShiftRows (Diffusion)**\n*   **Operation:** Cyclically shifts the rows of the matrix.\n*   **Mechanism:**\n    *   Row 0: No shift.\n    *   Row 1: Shift left 1.\n    *   Row 2: Shift left 2.\n    *   Row 3: Shift left 3.\n*   **Purpose:** Ensures columns are mixed in the next step. Prevents columns from being encrypted independently.\n\n**4. Layer 3: MixColumns (Diffusion)**\n*   **Operation:** Matrix multiplication.\n*   **Mechanism:** Each column is multiplied by a fixed polynomial matrix in $GF(2^8)$.\n*   **Purpose:** Spreads the influence of one input byte to all 4 output bytes in the column. Combined with ShiftRows, this creates the avalanche effect.\n\n**5. Layer 4: AddRoundKey (Key Mixing)**\n*   **Operation:** Bitwise XOR.\n*   **Mechanism:** $State = State \\oplus RoundKey_i$.\n*   **Purpose:** The only step that uses the secret key. It makes the encryption dependent on the key.\n\n**6. Conclusion**\nThese 4 layers are repeated 10-14 times (depending on key size) to create a military-grade cipher.",
        "graphviz": "digraph AESLayers {\n  rankdir=TD;\n  node [shape=box, style=filled, fillcolor=white];\n  \n  In [label=\"State Input\"];\n  SB [label=\"1. SubBytes\\n(Non-Linear)\", fillcolor=salmon];\n  SR [label=\"2. ShiftRows\\n(Permutation)\", fillcolor=lightblue];\n  MC [label=\"3. MixColumns\\n(Mixing)\", fillcolor=lightblue];\n  AK [label=\"4. AddRoundKey\\n(Key XOR)\", fillcolor=lightgreen];\n  Out [label=\"Round Output\"];\n  \n  In -> SB -> SR -> MC -> AK -> Out;\n}",
        "table": "| Layer | Type | Domain | Function |\n| :--- | :--- | :--- | :--- |\n| **SubBytes** | Substitution | Byte-level | Non-Linearity |\n| **ShiftRows** | Transposition | Matrix Row | Diffusion |\n| **MixColumns** | Arithmetic | Matrix Col | Diffusion |\n| **AddRoundKey**| XOR | Bit-level | Secrecy |"
    },
    {
        "q": "a. Describe the DES round function (f-function) and explain the role of expansion P box, S-boxes, and straight P-box.\n\nb. Explain about Ciphers in AES with a neat diagram.",
        "answer_a": "### **6(a). The DES Round Function (f-function)**\n\nThe security of DES resides entirely within the $f$-function, which transforms the right half of the block ($R$) using the round key ($K$).\n\n**1. Expansion P-Box (E)**\n*   **Input:** 32 bits.\n*   **Output:** 48 bits.\n*   **Action:** Duplicates half the bits. 32 bits are expanded to 48 so they can be XORed with the 48-bit key.\n*   **Role:** Diffusion and size matching.\n\n**2. Key Mixing**\n*   **Action:** $E(R) \\oplus K_i$.\n*   **Role:** Combines data with secret key.\n\n**3. S-Boxes (Substitution)**\n*   **Input:** 48 bits.\n*   **Output:** 32 bits.\n*   **Structure:** 8 separate S-Boxes. Each takes 6 bits in and gives 4 bits out.\n*   **Role:** The core engine of **Confusion**. It provides the non-linear transformation that makes DES secure against linear algebra attacks.\n\n**4. Straight P-Box (Permutation)**\n*   **Input:** 32 bits.\n*   **Output:** 32 bits.\n*   **Action:** Permutes bits (e.g., bit 1 moves to pos 16).\n*   **Role:** **Diffusion**. It spreads the output of one S-Box to the inputs of different S-Boxes in the next round.\n\n**5. Conclusion**\nThink of the f-function as a \"mixer\": Expand -> Salt with Key -> Chop (Sub) -> Shuffle (Perm).",
        "table_a": "| Step | Input | Output | Role |\n| :--- | :--- | :--- | :--- |\n| **E-Box** | 32 | 48 | Expand/Diffuse |\n| **XOR** | 48 | 48 | Add Key |\n| **S-Box** | 48 | 32 | Confuse (Non-linear) |\n| **P-Box** | 32 | 32 | Permute (Diffuse) |",
        "answer_b": "### **6(b). AES Cipher Structure**\n\n**1. Overview**\nAES is a Substitution-Permutation Network (SPN). Unlike DES, it is not a Feistel structure. It treats the 128-bit block as a single entity and transforms it in parallel.\n\n**2. Structure**\n*   **Initial Round:** Just one step: AddRoundKey. This key-whitening step is crucial to prevent attacks on the first round.\n*   **Main Rounds ($N_r - 1$):** \n    *   SubBytes\n    *   ShiftRows\n    *   MixColumns\n    *   AddRoundKey\n*   **Final Round:** \n    *   SubBytes\n    *   ShiftRows\n    *   AddRoundKey\n    *   *Note:* MixColumns is removed to make the cipher reversible (decryption structure matches encryption).\n\n**3. State Matrix**\nData is handled as a $4 \\times 4$ grid of bytes. e.g., $b_0$ to $b_{15}$.\n\n**4. Conclusion**\nThe simple, elegant structure of AES makes it easier to analyze for security flaws compared to the complex bit-twiddling of DES.",
        "graphviz_b": "digraph AESStruct {\n  rankdir=TD;\n  node [shape=box];\n  \n  In [label=\"Plaintext\"];\n  Init [label=\"Pre-Round:\\nAddRoundKey\", style=dashed];\n  \n  subgraph cluster_loop {\n    label=\"Rounds 1 to 9\";\n    style=filled; fillcolor=lightyellow;\n    Loop [label=\"SubBytes\\nShiftRows\\nMixColumns\\nAddRoundKey\"];\n  }\n  \n  Final [label=\"Final Round 10:\\nSubBytes\\nShiftRows\\nAddRoundKey\", style=filled, fillcolor=lightsalmon];\n  Out [label=\"Ciphertext\"];\n  \n  In -> Init -> Loop -> Final -> Out;\n}"
    },
    {
        "q": "a. Explain the components of a modern block cipher and their role in achieving confusion and diffusion.\n\nb. Describe Multiple DES. Explain the meet-in-the-middle attack on Double DES.",
        "answer_a": "### **9(a). Components of Modern Block Ciphers**\n\n**1. Introduction**\nModern ciphers are constructed using basic building blocks that, when combined, create a secure system. The goal is to satisfy Shannon's criteria: Confusion and Diffusion.\n\n**2. The Components**\n\n*   **Substitution Box (S-Box):**\n    *   **Mechanism:** Maps input bit patterns to output bit patterns via a lookup table.\n    *   **Role:** **Confusion**. It destroys linear relationships between plaintext and ciphertext.\n\n*   **Permutation Box (P-Box):**\n    *   **Mechanism:** Wired pathways that reorder bits.\n    *   **Types:** Straight (n to n), Expansion (n to n+k), Compression (n to n-k).\n    *   **Role:** **Diffusion**. Spreads information across the block.\n\n*   **Exclusive-OR (XOR):**\n    *   **Mechanism:** $A \\oplus B$.\n    *   **Role:** Mixing. Used to combine the key with data or combine left/right halves in Feistel networks. It is its own inverse ($A \\oplus B \\oplus B = A$).\n\n*   **Shift/Rotate:**\n    *   **Mechanism:** Cyclic shift of bits (e.g., `1011` $\\to$ `0111`).\n    *   **Role:** Diffusion.\n\n*   **Split/Swap:**\n    *   **Mechanism:** Used in Feistel ciphers to process halves alternately.\n\n**3. Conclusion**\nA single component is weak, but repeating them in layers creates a strong cipher.",
        "table_a": "| Component | Primary Goal | Example |\n| :--- | :--- | :--- |\n| **S-Box** | Confusion | AES SubBytes, DES S1-S8 |\n| **P-Box** | Diffusion | DES P-Box |\n| **Shift** | Diffusion | AES ShiftRows |\n| **XOR** | Mixing | AddRoundKey |",
        "answer_b": "### **9(b). Multiple DES & Meet-in-the-Middle Attack**\n\n**1. Multiple DES**\nTo fix DES's small key size (56 bits), we apply DES multiple times.\n*   **Double DES (2DES):** $C = E_{K2}(E_{K1}(P))$. (Key: 112 bits).\n*   **Triple DES (3DES):** $C = E_{K3}(D_{K2}(E_{K1}(P)))$. (Key: 168 bits).\n\n**2. Meet-in-the-Middle (MITM) on 2DES**\nYou might think 2DES has $2^{112}$ security. However, Merkle and Diffie showed it is much weaker ($2^{57}$) due to MITM.\n\n**3. The Attack**\n*   **Equation:** $C = E_{K2}(E_{K1}(P))$.\n*   **Transform:** Decrypt $K2$ side $\\to$ $D_{K2}(C) = E_{K1}(P)$. Let this intermediate value be $M$.\n\n**4. Algorithm**\n1.  **Encrypt Phase:** Encrypt $P$ with all $2^{56}$ possible values of $K1$. Store pairs $(M, K1)$ in a **Hash Table**.\n2.  **Decrypt Phase:** Decrypt $C$ with all $2^{56}$ possible values of $K2$. Get result $M'$.\n3.  **Match:** Check if $M'$ exists in the Hash Table.\n4.  **Result:** If found, the pair $(K1, K2)$ is the key.\n\n**5. Cost**\n*   Time: $2^{56} + 2^{56} = 2^{57}$ steps.\n*   Memory: Huge table for $2^{56}$ entries.\n\n**6. Conclusion**\nBecause $2^{57}$ is barely safer than $2^{56}$, 2DES is useless. We strictly use 3DES or AES.",
        "graphviz_b": "digraph MITM {\n  rankdir=LR;\n  node [shape=box];\n  \n  P [label=\"Plaintext\"];\n  C [label=\"Ciphertext\"];\n  \n  List [label=\"Table of\\nAll E_k1(P)\", shape=folder, style=filled, fillcolor=lightblue];\n  Check [label=\"Compare M' to Table\", shape=diamond, style=filled, fillcolor=lightyellow];\n  Found [label=\"Keys Found!\"];\n  \n  P -> List [label=\"Encrypt with all K1\"];\n  C -> Check [label=\"Decrypt with all K2\"];\n  List -> Check;\n  Check -> Found;\n}"
    }
]